package com.github.morulay.shiro.aad;

import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.shiro.SecurityUtils;
import org.apache.shiro.codec.Base64;
import org.apache.shiro.crypto.AesCipherService;
import org.apache.shiro.crypto.CipherService;
import org.apache.shiro.io.DefaultSerializer;
import org.apache.shiro.io.Serializer;
import org.apache.shiro.subject.PrincipalCollection;
import org.apache.shiro.subject.Subject;
import org.apache.shiro.util.ByteSource;
import org.apache.shiro.web.filter.PathMatchingFilter;
import org.apache.shiro.web.mgt.CookieRememberMeManager;
import org.apache.shiro.web.servlet.Cookie;
import org.apache.shiro.web.servlet.Cookie.SameSiteOptions;
import org.apache.shiro.web.servlet.SimpleCookie;
import org.apache.shiro.web.util.WebUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** Inspired by and mostly copy &amp; paste from {@link CookieRememberMeManager} */
public class CookieRunAsFilter extends PathMatchingFilter {

  private static final Logger log = LoggerFactory.getLogger(CookieRunAsFilter.class);

  /**
   * The following Base64 string was generated by auto-generating an AES Key:
   *
   * <pre>
   * AesCipherService aes = new AesCipherService();
   * byte[] key = aes.generateNewKey().getEncoded();
   * String base64 = Base64.encodeToString(key);
   * </pre>
   *
   * The value of 'base64' was copied-n-pasted here:
   */
  private static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode("kPH+bIxk5D2deZiIxcaaaA==");

  /** Serializer to use for converting PrincipalCollection instances to/from byte arrays */
  private Serializer<PrincipalCollection> serializer;

  /** Cipher to use for encrypting/decrypting serialized byte arrays for added security */
  private CipherService cipherService;

  /** Cipher encryption key to use with the Cipher when encrypting data */
  private byte[] encryptionCipherKey;

  /** Cipher decryption key to use with the Cipher when decrypting data */
  private byte[] decryptionCipherKey;

  /** The default name of the underlying rememberMe cookie which is {@code rememberMe}. */
  public static final String RUN_AS_COOKIE_NAME = "runas_token";

  private Cookie runAsCookieTemplate;

  /**
   * Default constructor that initializes a {@link DefaultSerializer} as the {@link #getSerializer()
   * serializer} and an {@link AesCipherService} as the {@link #getCipherService() cipherService}.
   */
  public CookieRunAsFilter() {
    this.serializer = new DefaultSerializer<>();
    this.cipherService = new AesCipherService();
    setCipherKey(DEFAULT_CIPHER_KEY_BYTES);

    runAsCookieTemplate = new SimpleCookie(RUN_AS_COOKIE_NAME);
    runAsCookieTemplate.setHttpOnly(true);
    runAsCookieTemplate.setMaxAge(Cookie.ONE_YEAR);
    runAsCookieTemplate.setSameSite(SameSiteOptions.STRICT);
  }

  /**
   * Returns the {@code Serializer} used to serialize and deserialize {@link PrincipalCollection}
   * instances for persistent remember me storage.
   *
   * <p>Unless overridden by the {@link #setSerializer} method, the default instance is a {@link
   * org.apache.shiro.io.DefaultSerializer}.
   *
   * @return the {@code Serializer} used to serialize and deserialize {@link PrincipalCollection}
   *     instances for persistent remember me storage.
   */
  public Serializer<PrincipalCollection> getSerializer() {
    return serializer;
  }

  /**
   * Sets the {@code Serializer} used to serialize and deserialize {@link PrincipalCollection}
   * instances for persistent remember me storage.
   *
   * <p>Unless overridden by this method, the default instance is a {@link DefaultSerializer}.
   *
   * @param serializer the {@code Serializer} used to serialize and deserialize {@link
   *     PrincipalCollection} instances for persistent remember me storage.
   */
  public void setSerializer(Serializer<PrincipalCollection> serializer) {
    this.serializer = serializer;
  }

  /**
   * Returns the {@code CipherService} to use for encrypting and decrypting serialized identity data
   * to prevent easy inspection of Subject identity data.
   *
   * <p>Unless overridden by the {@link #setCipherService} method, the default instance is an {@link
   * AesCipherService}.
   *
   * @return the {@code Cipher} to use for encrypting and decrypting serialized identity data to
   *     prevent easy inspection of Subject identity data
   */
  public CipherService getCipherService() {
    return cipherService;
  }

  /**
   * Sets the {@code CipherService} to use for encrypting and decrypting serialized identity data to
   * prevent easy inspection of Subject identity data.
   *
   * <p>If the CipherService is a symmetric CipherService (using the same key for both encryption
   * and decryption), you should set your key via the {@link #setCipherKey(byte[])} method.
   *
   * <p>If the CipherService is an asymmetric CipherService (different keys for encryption and
   * decryption, such as public/private key pairs), you should set your encryption and decryption
   * key via the respective {@link #setEncryptionCipherKey(byte[])} and {@link
   * #setDecryptionCipherKey(byte[])} methods.
   *
   * <p><b>N.B.</b> Unless overridden by this method, the default CipherService instance is an
   * {@link AesCipherService}. This {@code RememberMeManager} implementation already has a
   * configured symmetric key to use for encryption and decryption, but it is recommended to provide
   * your own for added security. See the class-level JavaDoc for more information and why it might
   * be good to provide your own.
   *
   * @param cipherService the {@code CipherService} to use for encrypting and decrypting serialized
   *     identity data to prevent easy inspection of Subject identity data.
   */
  public void setCipherService(CipherService cipherService) {
    this.cipherService = cipherService;
  }

  /**
   * Returns the cipher key to use for encryption operations.
   *
   * @return the cipher key to use for encryption operations.
   * @see #setCipherService for a description of the various {@code get/set*Key} methods.
   */
  public byte[] getEncryptionCipherKey() {
    return encryptionCipherKey;
  }

  /**
   * Sets the encryption key to use for encryption operations.
   *
   * @param encryptionCipherKey the encryption key to use for encryption operations.
   * @see #setCipherService for a description of the various {@code get/set*Key} methods.
   */
  public void setEncryptionCipherKey(byte[] encryptionCipherKey) {
    this.encryptionCipherKey = encryptionCipherKey;
  }

  /**
   * Returns the decryption cipher key to use for decryption operations.
   *
   * @return the cipher key to use for decryption operations.
   * @see #setCipherService for a description of the various {@code get/set*Key} methods.
   */
  public byte[] getDecryptionCipherKey() {
    return decryptionCipherKey;
  }

  /**
   * Sets the decryption key to use for decryption operations.
   *
   * @param decryptionCipherKey the decryption key to use for decryption operations.
   * @see #setCipherService for a description of the various {@code get/set*Key} methods.
   */
  public void setDecryptionCipherKey(byte[] decryptionCipherKey) {
    this.decryptionCipherKey = decryptionCipherKey;
  }

  /**
   * Convenience method that returns the cipher key to use for <em>both</em> encryption and
   * decryption.
   *
   * <p><b>N.B.</b> This method can only be called if the underlying {@link #getCipherService()
   * cipherService} is a symmetric CipherService which by definition uses the same key for both
   * encryption and decryption. If using an asymmetric CipherService public/private key pair, you
   * cannot use this method, and should instead use the {@link #getEncryptionCipherKey()} and {@link
   * #getDecryptionCipherKey()} methods individually.
   *
   * <p>The default {@link AesCipherService} instance is a symmetric cipher service, so this method
   * can be used if you are using the default.
   *
   * @return the symmetric cipher key used for both encryption and decryption.
   */
  public byte[] getCipherKey() {
    // Since this method should only be used with symmetric ciphers
    // (where the enc and dec keys are the same), either is fine, just return one of them:
    return getEncryptionCipherKey();
  }

  /**
   * Convenience method that sets the cipher key to use for <em>both</em> encryption and decryption.
   *
   * <p><b>N.B.</b> This method can only be called if the underlying {@link #getCipherService()
   * cipherService} is a symmetric CipherService?which by definition uses the same key for both
   * encryption and decryption. If using an asymmetric CipherService?(such as a public/private key
   * pair), you cannot use this method, and should instead use the {@link
   * #setEncryptionCipherKey(byte[])} and {@link #setDecryptionCipherKey(byte[])} methods
   * individually.
   *
   * <p>The default {@link AesCipherService} instance is a symmetric CipherService, so this method
   * can be used if you are using the default.
   *
   * @param cipherKey the symmetric cipher key to use for both encryption and decryption.
   */
  public void setCipherKey(byte[] cipherKey) {
    // Since this method should only be used in symmetric ciphers
    // (where the enc and dec keys are the same), set it on both:
    setEncryptionCipherKey(cipherKey);
    setDecryptionCipherKey(cipherKey);
  }

  /**
   * Converts the given principal collection the byte array that will be persisted to be
   * 'remembered' later.
   *
   * <p>This implementation first {@link #serialize(org.apache.shiro.subject.PrincipalCollection)
   * serializes} the principals to a byte array and then {@link #encrypt(byte[]) encrypts} that byte
   * array.
   *
   * @param principals the {@code PrincipalCollection} to convert to a byte array
   * @return the representative byte array to be persisted for remember me functionality.
   */
  protected byte[] convertPrincipalsToBytes(PrincipalCollection principals) {
    byte[] bytes = serialize(principals);
    if (getCipherService() != null) {
      bytes = encrypt(bytes);
    }
    return bytes;
  }

  /**
   * If a {@link #getCipherService() cipherService} is available, it will be used to first decrypt
   * the byte array. Then the bytes are then {@link #deserialize(byte[]) deserialized} and then
   * returned.
   *
   * @param bytes the bytes to decrypt if necessary and then deserialize.
   * @return the de-serialized and possibly decrypted principals
   */
  protected PrincipalCollection convertBytesToPrincipals(byte[] bytes) {
    if (getCipherService() != null) {
      bytes = decrypt(bytes);
    }
    return deserialize(bytes);
  }

  /**
   * Encrypts the byte array by using the configured {@link #getCipherService() cipherService}.
   *
   * @param serialized the serialized object byte array to be encrypted
   * @return an encrypted byte array returned by the configured {@link #getCipherService () cipher}.
   */
  protected byte[] encrypt(byte[] serialized) {
    byte[] value = serialized;
    CipherService cipherService = getCipherService();
    if (cipherService != null) {
      ByteSource byteSource = cipherService.encrypt(serialized, getEncryptionCipherKey());
      value = byteSource.getBytes();
    }
    return value;
  }

  /**
   * Decrypts the byte array using the configured {@link #getCipherService() cipherService}.
   *
   * @param encrypted the encrypted byte array to decrypt
   * @return the decrypted byte array returned by the configured {@link #getCipherService ()
   *     cipher}.
   */
  protected byte[] decrypt(byte[] encrypted) {
    byte[] serialized = encrypted;
    CipherService cipherService = getCipherService();
    if (cipherService != null) {
      ByteSource byteSource = cipherService.decrypt(encrypted, getDecryptionCipherKey());
      serialized = byteSource.getBytes();
    }
    return serialized;
  }

  /**
   * Serializes the given {@code principals} by serializing them to a byte array by using the {@link
   * #getSerializer() serializer}'s {@link Serializer#serialize(Object) serialize} method.
   *
   * @param principals the principal collection to serialize to a byte array
   * @return the serialized principal collection in the form of a byte array
   */
  protected byte[] serialize(PrincipalCollection principals) {
    return getSerializer().serialize(principals);
  }

  /**
   * De-serializes the given byte array by using the {@link #getSerializer() serializer}'s {@link
   * Serializer#deserialize deserialize} method.
   *
   * @param serializedIdentity the previously serialized {@code PrincipalCollection} as a byte array
   * @return the de-serialized (reconstituted) {@code PrincipalCollection}
   */
  protected PrincipalCollection deserialize(byte[] serializedIdentity) {
    return getSerializer().deserialize(serializedIdentity);
  }

  public boolean isRunAs(HttpServletRequest request, HttpServletResponse response) {
    return runAsCookieTemplate.readValue(request, response) != null;
  }

  public PrincipalCollection readRunAs(HttpServletRequest request, HttpServletResponse response) {
    String base64 = runAsCookieTemplate.readValue(request, response);
    if (base64 == null) {
      return null;
    }
    base64 = ensurePadding(base64);
    log.trace("Acquired Base64 encoded identity [{}]", base64);
    byte[] decoded = Base64.decode(base64);
    log.trace("Base64 decoded byte array length: {} bytes.", decoded != null ? decoded.length : 0);
    return convertBytesToPrincipals(decoded);
  }

  public void storeRunAs(
      PrincipalCollection principals, HttpServletRequest request, HttpServletResponse response) {
    byte[] bytes = convertPrincipalsToBytes(principals);
    String base64 = Base64.encodeToString(bytes);
    Cookie runAsCookie = new SimpleCookie(runAsCookieTemplate);
    runAsCookie.setValue(base64);
    runAsCookie.saveTo(request, response);
  }

  public void removeRunAs(HttpServletRequest request, HttpServletResponse response) {
    if (runAsCookieTemplate.readValue(request, response) != null) {
      runAsCookieTemplate.removeFrom(request, response);
    }
  }

  @Override
  protected boolean onPreHandle(
      ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {

    HttpServletRequest httpRequest = WebUtils.toHttp(request);
    HttpServletResponse httpResponse = WebUtils.toHttp(response);

    if (!isRunAs(httpRequest, httpResponse)) {
      return true;
    }

    PrincipalCollection principals = readRunAs(httpRequest, httpResponse);
    Subject subject = SecurityUtils.getSubject();
    if (subject.isAuthenticated()) {
      subject.runAs(principals);
    } else {
      removeRunAs(httpRequest, httpResponse);
    }

    return true;
  }

  @Override
  public void afterCompletion(ServletRequest request, ServletResponse response, Exception exception)
      throws Exception {

    HttpServletRequest httpRequest = WebUtils.toHttp(request);
    HttpServletResponse httpResponse = WebUtils.toHttp(response);

    Subject subject = SecurityUtils.getSubject();
    if (subject.isAuthenticated() && subject.isRunAs()) {
      storeRunAs(subject.getPrincipals(), httpRequest, httpResponse);
    } else if (isRunAs(httpRequest, httpResponse)) {
      removeRunAs(httpRequest, httpResponse);
    }
  }

  /**
   * Sometimes a user agent will send the rememberMe cookie value without padding, most likely
   * because {@code =} is a separator in the cookie header.
   *
   * <p>Contributed by Luis Arias. Thanks Luis!
   *
   * @param base64 the base64 encoded String that may need to be padded
   * @return the base64 String padded if necessary.
   */
  private String ensurePadding(String base64) {
    int length = base64.length();
    if (length % 4 != 0) {
      StringBuilder sb = new StringBuilder(base64);
      for (int i = 0; i < length % 4; ++i) {
        sb.append('=');
      }
      base64 = sb.toString();
    }
    return base64;
  }
}
